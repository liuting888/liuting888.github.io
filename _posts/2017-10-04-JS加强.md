---
layout: post
title: "JavaScript强化"
date: 2017-10-05 
description: "JavaScript强化"
tag: 博客 
---   
# JavaScript

## JS基础

### Javascript组成

1. ECMAscript:规范了js的语法规范和语言使用标准
2. DOM:文档对象模型，一套api,提供了一套操作页面元素相关的api
3. BOM:browser object model-浏览器对象模型，提供一套用来操作浏览器相关信息的api

### Js中常用的数据类型

1. 简单数据类型：string number boolean
2. 复杂数据类型:Object function Array Date RegExp  Math…
3. 空类型：null undefined

### 判断数据类型
    typeof关键字，返回值的类型为string

    * a)string number boolean > string number boolean  
    * b)对象/数组>object    
    * c)function(){} > function     
    * d)null > object    
    * e)undefined > undefined   

### 相等和全等
1. 相等：只判断值是否相等
2. 全等：判断类型和值是否相等(先判断类型再判断值)
3. c)如果是值和引用进行比较，会将引用类型转换为值类型的数据，首先调用valueOf获取引用类型的数据，如果无法获取到值，那么就会调用引用类型数据的toString()方法获取值 {} == !{}    [] == ![]

### In关键字
1. For-in：遍历对象
2. 属性 in 对象：判断对象是否可以访问某个属性,而不关注这个属性是否是对象自身中定义的

### 值类型和引用类型
1. 值类型：空间直接存储值
2. 引用类型：变量存储的是数据的地址，数据单独存储，变量存储的地址指向数据
3. 值类型和引用类型在赋值值的特点
* 值类型的变量复制(参数传递)的时候是将值复制一份赋值给新的变量，修改其中一个不会影响另外的变量值
* 引用类型的变量复制(参数传递)是将存储的地址复制一份给新的变量，两个变量会指向同一个地址空间，修改其中一个另外的变量也会有相应的变化

### 逻辑中断
1. ||中断：如果表达式1的值为真，就返回表达式1，否则返回表达式2
2. &&中断：如果表达式1为假，则返回表达式1的值，否则返回表达式2的值

### Delete关键字的使用：
1. 可以删除未使用var声明的变量
2. 可以删除对象的属性，删除之后属性值为undefined。注意：如果访问一个不存在的变量，则会报错，但是如果删除一个不存在的属性，则不会报错，只是会返回undefined。
3. Delete关键字有返回值，但是不可靠，所以一般情况下不要使用这个返回值来进行相应的判断(通过Object.defineProperty方法添加的属性无法删除)
4. 使用delelte删除数组中的元素的时候，数组中的后面的元素的索引不会自动变化靠前，数组的长度也不会自动变化

### 对象的动态特性：
1. 在对象创建完成之后，可以随时为对象添加任何属性和行为的特性—动态特性
2. 使用方式：
* 点语法：对象.属性
* 关联数组语法：对象[属性名称]

### DOM操作复习：
	增加：createElement   clone  appendChild  insertBefore   innerHTML
	删除：removeChild   innerHTML
	修改：innerHTML  setAttribute  style
	查询：getElementById   getElementsByTagName   getElementsByClassName   querySelector   querySelectorAll

### 异常处理：异常会导致异常出现后面的代码不能正常的执行
1. 语法：
```
try{
可能会出错的代码
}catch(e){
捕获异常后的处理代码
}finally{
无论是否出错都会执行的代码，如释放资源
}
```
2. e就是捕获到的异常信息
3. 抛出异常：throw，可以抛出提示信息字符串值，也可以抛出对象
4. 抛出的异常就是捕获的异常
5. 注意：
* 死循环并不会报错，但是递归会报错
* 语法错误并不会进行捕获，因为语法错误在代码运行前就已经出现了
* 异常会导致后面的代码无法正常执行
* 异常捕获处理的目的就是为了当异常出现后不会影响后面代码的执行

## 面向对象
1. 什么是对象？
* 万物皆对象
* 对象的特征和行为

2. Js中的对象：
* 无序的键值对的集合 hash算法 ，索引才是有序的，键值是无序的
* 属性对应着特征
* 函数方法对应着行为

3. 面向对象能够解决什么？
* 解决了全局变量污染
* 解决了代码混乱*

### 创建对象
1. 使用字面量的方式
* 通过对象字面量创建对象的时候本质是在调用new Object
* 通过数组字面量创建对象的进修本质是在调用new Array
* 通过正则字面量创建对象的时候本质是在调用new RegExp

2. 使用函数封装
```js
var createPerson=function(name,age){
    var obj=new Object();
    obj.name=name;
    obj.age=age;
    return obj;
}
var jack=createPerson('jack',20);
```

3. 使用自定义构造函数
```js
function  Person(name,age){
    this.name=name;
    this.age=age;
}
var per1=new Person('jack',20);
```

### 面向对象的三大特性：封装，继承，多态
1. 封装：将功能封装在对象中，对象会提供外部使用的接口，外界在使用的时候，只需要考虑如何调用接口，而不需要考虑内部的具体实现。
2. 继承：js中的某些对象没有一些需要的属性和方法，但是另外的对象有，那么拿过来使用，就是继承
3. 多态：js中没有多态，多态一般是体现在强类型的编程语言中。

### 继承

#### 继承的实现方式
1. 混入式(max-in)继承：通过循环将一个对象中的所有属性和方法混入到另外一个对象中
```js 
var me={
    work:function(){
        console.log('打工');
    }
};
var mayun={
    money:9999999999,
    car:'QQ',
    manager:function(){
        console.log('管理阿里巴巴。。。');
    }
}
/*遍历，让me对象拥有mayun对象的所有属性*/
for(var key in mayun){
    me[key]=mayun[key];
}
```

2. 使用原型实现继承
    * 修改构造函数的protoType属性来设置原型，但是原型只有一个，所以这种方式无法指定多种原型，后面指定的原型会覆盖前面指定的原型
    * 利用混入的方式给原型添加属性和方法

3. 经典的实现继承的方式
* Object.create()：
* 解决兼容问题：
```js
    var source={
        name:'jack',
        age:20
    }
    /*解决经典继承方式的兼容*/
    function myCreate(){
        /*判断浏览器是否支持经典继承方式*/
        if(Object.create){
            var son=Object.create(source);
            return son;
        }
        else{
            function UserDefine(){}
            UserDefine.prototype=source;
            var son=new UserDefine();
            return son;
        }
    }
```
#### 继承的使用—扩展内置对象
1. 如何安全的扩展内置对象--不能直接为系统的内置对象扩展属性和方法，因为它是共用的
* 创建自定义的构造函数
* 实现原型继承，如继承自一个数组对象
* 为自定义的构造函数的原型扩展属性和方法
* 通过自定义的构造函数创建出的对象，既拥有系统数组的属性和方法，又拥有自定义的属性和方法
* 自定义的类型不会对其它的类型产生影响
2. 示例：
```js
    /*使用js内置对象*/
    var arr1=new Array();
    /*为系统的内置对象添加一些自定义属性或方法*/
    Array.prototype.sayHi=function(){
        console.log('我是第一个对象');
    }
    arr1.sayHi();

    /*创建第二个对象*/
    var arr2=new Array();
    /*为第二个对象添加自定义的属性或方法 */
    Array.prototype.sayHi=function(){
        console.log('我是第二个对象');
    }
    arr2.sayHi();
    /*但是，如果再用第一个对象来进行属性或方法的调用，则发现覆盖*/
    arr1.sayHi();
    /*解决：创建自定义数组，为当前数组添加独立的属性或方法，而不是去修改共享的内置对象，否则修改一个，其它使用的时候也发生改变*/
    function  MyArray(){}
    /*让自定义的类型是一个数组--拥有数组的属性和方法 */
    MyArray.prototype=[];
    MyArray.prototype.sayHi=function(){
        console.log('对象1向你问好');
    }
    /*使用自定义类型创建对象*/
    var arr3=new MyArray();
    arr3.push(1,2,3,4,5);
    console.log(arr3);
    arr3.sayHi();
    arr2.sayHi();
    arr1.sayHi();
```

### 构造函数
1. 什么是构造函数：构造函数是用来初始化对象的

2. 构造函数的特征：
* 首字母大写--规范
* 构造函数一般和new关键字一起使用
* 构造函数不需要手动的写返回值

3. 构造函数的执行过程：
* 通过new关键字创建对象
* 调用构造函数将构造函数中的this指向创建出来的对象
* 在构造函数内部，通过this对对象新增属性和方法--初始化操作
* 自动返回创建好的对象

4. 注意事项
* 如果在构造函数中写了return语句
    * 如果返回了简单数据类型，不会对构造函数的返回值造成影响，依然是构造函数中创建的对象
    * 如果返回了复杂数据类型，则会返回该复杂数据类型
* 如果像调用普通函数一样调用构造函数
    * 函数中的this会指向window对象，通过this添加的所有属性和方法会添加到window对象以上	
    * 如果函数中没有return语句，则返回undefined

### 原型 
1. 什么是原型：构造函数在创建出来的时候，系统会默认帮这个构造函数创建并且关联一个空的对象， 这个对象就是原型

2. 原型的作用：通过和原型关联的构造函数所创建出来的所有对象，都会共享原型中声明的属性和方法—(相当于后台语言中的父类)

3. 如何访问原型：可以通过构造函数名称.protoType获取原型。如：Person.prototype

4. 如何在原型中添加属性和方法：
* 利用对象的动态特性为原型添加属性和方法 。具体可以通过类型.protoType来添加属性和方法,如:
```
Person.prototype.address='北京';
console.log(per.address);
```

* 直接为构造函数的原型属性protoType赋值一个新的对象
```js
Person.prototype={
    gender:'male',
    phone:'12345'
}
var per2=new Person();
console.log(per2.phone);
```
5. 使用原型注意事项：
* 原型的成员需要先添加再使用
* 公共的成员才可以放到原型中，不同对象的不同的属性应该放在各自对象内
* 在获取某些成员的时候，如果当前对象中没有，才会去原型中获取
* 在使用对象设置属性的值的时候，只会在对象自身进行查找，如果有，就进行修改，如果没有就会新增
* 在给构造函数的原型属性protoType赋值一个新的对象，会造成赋值前后创建的对象所指向的原型不一样，所以建议先赋值新对象之后再通过构造函数创建对象

6. __proto__属性的介绍
```js 
    function  Person(name,age){
        this.name=name;
        this.age=age;
    }
    var p=new Person('jack',20);
    console.log(Person.prototype);
    /*__proto__是一个非标准的属性，不同浏览器会有兼容的问题，所以不推荐在工作和项目中使用，只在自己调试代码的时候使用*/
    console.log(p.__proto__);
    console.log(Person.prototype === p.__proto__);
```
7. constructor属性：
```js
    function  Person(){
    }
    /*constructor:指向和原型对应的构造函数*/
    console.log(Person.prototype.constructor);
    console.log(Person.prototype.constructor === Person); //true
```
注意：当构造函数.protoType重新赋值为一个新的对象的时候，新的对象中需要手动新增constructor属性，让原型可以正常的和构造关联起来，但是constructor属性不是必须要修改的内容，如果没有重新指向，对使用也不会有影响，但是一般情况下，都推荐改成正常的指向。   

### 原型链：
1. 概念：对象都有原型，原型是一个对象，所以原型又有原型，这样就形成了一个原型链
2. 属性搜索原则：当使用对象去访问一个属性或者方法的时候
* 先在对象自身中进行查找，如果找到就直接使用
* 如果没有找到，就去对象的原型中进行查找，如果找到直接使用
* 如果没有找到，就沿着原型链依次向上查找，直到找到null
3. instanceof关键字
* 判断构造函数的protoType属性是否在对象的原型链上
4. 完整的原型链：函数有两重身份，一重是构造函数，一重是对象
<img src="/images/posts/js/JS加强/2.png" width = "500" />

### Function
1. 函数也是一个对象，对象都是通过构造函数创建的，函数的构造函数就是Function,,JS中所有的函数的构造函数都是Function,可以通过new Function()来创建

2. Function初步使用：
```js 
    /*1.如果直接使用new Function()而不传入任何的参数，那么就会创建出一个匿名函数
    * 2.可以给函数传递一个参数，这个参数后期就会成为函数的函数体*/
    /*var fun=new Function();
     console.log(typeof fun);
     console.log(fun);*/
    var fun=new Function('console.log("能不能输出")');
    fun();
    /*3.也可以给函数传入多个参数，前面的参数都是函数的参数，最后一个是函数体*/
    var calculate=new Function("a","b","return a+b;");
    var result=calculate(4,5);
    console.log(result);
```

3.Function代码过长的问题的解决：
* 拼接字符串
* 使用反引号``
* 使用\
* 使用模板

4. eval函数的使用：可以将字符串的内容当成js代码来执行
```js
    /*可以将eval中的字符串当成代码来解析*/
    eval("var num=100;");
    console.log(num);
    /*可以将json格式字符串转换为json对象
    * 注意：
    * 1.eval函数会将json格式的字符串的{}当成代码块处理，造成报错
    * 2.所以。可以给这个json字符串前后拼接一个()
    * 3.这样，加了()后的字符串就会被认为是一个字面量来处理了*/
    var jsonStr='{"name":"jack","age":20}';
//    var obj=eval("("+jsonStr+")");
    eval("var obj="+jsonStr);
    console.log(obj);
```

5. 函数对象的属性
* arguments:函数内部的一个变量，它是一个伪数组。当函数被调用的时候，会将所有的实参依次存入这个伪数组中，它只有在函数被调用的时候才会有值，它与函数.arguments的功能一样，存储的内容也一样，但并非同一个对象
* caller:获取当前函数是在哪个函数中被调用，注意，这个属性值必须在函数被调用的才能取到值，所以需要将 函数.caller 代码写在函数体内，当这段代码被执行的时候，就是这个函数被调用的时候。同时需要注意的时候，如果是全局调用，那么caller只能返回null
* length:形参的数量
* name:函数名称.通过函数表达式声明的函数，函数的name就是变量名称
* protoType:函数的原型

6. 函数的作用域链：
* 只有函数可以创建作用域
* 在函数中可以嵌套函数，这样就形成了作用域中嵌套另外一个作用域，这就形成了作用域链
* 作用域链中变量的搜索原则：
    * 首先在当前使用变量的作用域中查找，如果找到就使用，否则查找上一级作用域
    * 查找上一级作用域，如果找到就使用，否则再查找上一级作用域
    * 如果没有，就一直沿着作用域往上找，直到找到全局的作用域为止
* 访问规则：由内至外
    * 内层作用域可以访问外层作用域中的变量
    * 外层作用域不能直接访问内层作用域中的变量

7. 函数的原型链：
<img src="/images/posts/js/JS加强/1.png" width = "500" />


### 伪数组
1.概念：伪数组拥有与数组一样的下标，可以通过下标来访问各种元素，拥有长度属性，可以表示其中存储的元素的数量。但是没有数组类似的方法

### 静态成员和实例成员：
1. 静态成员：通过构造函数访问的成员  >>  函数名.成员

2. 实例成员：通过实例对象访问的成员  >>  实例对象.成员


### 作用域：
1. 概念：变量起作用的范围

2. 在js中，只有函数可以创建作用域

3. 词法作用域(静态作用域)：根据代码的书写结构去确定变量的作用范围，与调用没有关系。意味着在使用一个变量的时候，首先在自己的作用域中查找，如果没有就去上一级作用域中查找

4. 注意：js中没有块级作用域，意味着在if或者for中定义的变量在它们的外部也能够访问

### 变量名提升：
1. js代码的执行过程包含：预解析和执行

2. 在代码的预解析阶段，js引擎会将所有的变量声明，以及函数声明提升到其所在的作用域的最顶端

3. 当函数和函数同名，都会进行提升，造成后面声明的函数覆盖前面的函数

4. 当函数和变量名同名的时候，只会提升函数，忽略变量的声明

5. 用表达式创建的函数不能进行提升，只有对应的变量名称能够进行提升

6. 条件式函数声明：就是在条件语句是声明的函数，在变量提升的时候会被当函数表达式来处理

7. 变量提升是分Script标签的。所有的全局的函数或者变量的声明，只会被提升到当前Script标签的最顶端

### Object.defineProperty
1 .作用：这个方法会直接在一个对象上定义一个新的属性或者修改一个已经存在的属性，并返回这个对象。

2. 语法：Object.defineProperty(obj,prop,descriptor)
* Obj:要添加属性或者修改属性的对象
* Prop:要修改或者添加的属性名称
* Descriptor:标记属性能否被删除，修改或者遍历。。。相当于配置属性的特性，它是一个对象

3. 注意：get/set方法不能和value和writable属性一起使用