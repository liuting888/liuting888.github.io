---
layout: post
title: "JavaScript强化"
date: 2017-10-05 
description: "JavaScript强化"
tag: 博客 
---   
# JavaScript

## JS基础

### Javascript组成

1. ECMAscript:规范了js的语法规范和语言使用标准
2. DOM:文档对象模型，一套api,提供了一套操作页面元素相关的api
3. BOM:browser object model-浏览器对象模型，提供一套用来操作浏览器相关信息的api

### Js中常用的数据类型

1. 简单数据类型：string number boolean
2. 复杂数据类型:Object function Array Date RegExp  Math…
3. 空类型：null undefined

### 判断数据类型
    typeof关键字，返回值的类型为string

    * a)string number boolean > string number boolean  
    * b)对象/数组>object    
    * c)function(){} > function     
    * d)null > object    
    * e)undefined > undefined   

### 相等和全等
1. 相等：只判断值是否相等
2. 全等：判断类型和值是否相等(先判断类型再判断值)
3. c)如果是值和引用进行比较，会将引用类型转换为值类型的数据，首先调用valueOf获取引用类型的数据，如果无法获取到值，那么就会调用引用类型数据的toString()方法获取值 {} == !{}    [] == ![]

### In关键字
1. For-in：遍历对象
2. 属性 in 对象：判断对象是否可以访问某个属性,而不关注这个属性是否是对象自身中定义的

### 值类型和引用类型
1. 值类型：空间直接存储值
* `数值类型`
* `布尔类型`
* `undefined`
* `null`
* `字符串`

2. 引用类型：变量存储的是数据的地址，数据单独存储，变量存储的地址指向数据
* `对象`
* `数组`
* `函数`

3. 值类型和引用类型在赋值值的特点
* 值类型的变量复制(参数传递)的时候是将值复制一份赋值给新的变量，修改其中一个不会影响另外的变量值
* 引用类型的变量复制(参数传递)是将存储的地址复制一份给新的变量，两个变量会指向同一个地址空间，修改其中一个另外的变量也会有相应的变化
* 在调用函数的时候，传参的过程其实就是用实参给形参赋值的过程
* 当参数为值类型的时候，函数内和函数外的两个变量完全不同，仅仅只是存的值一样而已，修改时互不影响
* 当参数为引用类型的时候，函数内和函数外的两个变量不同，但是共同指向同一个对象，在函数内修改对象数据时会影响外部

### 逻辑中断
1. \||中断：如果表达式1的值为真，就返回表达式1，否则返回表达式2
2. &&中断：如果表达式1为假，则返回表达式1的值，否则返回表达式2的值

### Delete关键字的使用：
1. 可以删除未使用var声明的变量
2. 可以删除对象的属性，删除之后属性值为undefined。注意：如果访问一个不存在的变量，则会报错，但是如果删除一个不存在的属性，则不会报错，只是会返回undefined。
3. Delete关键字有返回值，但是不可靠，所以一般情况下不要使用这个返回值来进行相应的判断(通过Object.defineProperty方法添加的属性无法删除)
4. 使用delelte删除数组中的元素的时候，数组中的后面的元素的索引不会自动变化靠前，数组的长度也不会自动变化

### 对象的动态特性：
1. 在对象创建完成之后，可以随时为对象添加任何属性和行为的特性—动态特性
2. 使用方式：
* 点语法：对象.属性
* 关联数组语法：对象[属性名称]

### DOM操作复习：
	增加：createElement   clone  appendChild  insertBefore   innerHTML
	删除：removeChild   innerHTML
	修改：innerHTML  setAttribute  style
	查询：getElementById   getElementsByTagName   getElementsByClassName   querySelector   querySelectorAll

### 异常处理：异常会导致异常出现后面的代码不能正常的执行
1. 语法：
```
try{
可能会出错的代码
}catch(e){
捕获异常后的处理代码
}finally{
无论是否出错都会执行的代码，如释放资源
}
```
2. e就是捕获到的异常信息
3. 抛出异常：throw，可以抛出提示信息字符串值，也可以抛出对象
4. 抛出的异常就是捕获的异常
5. 注意：
* 死循环并不会报错，但是递归会报错
* 语法错误并不会进行捕获，因为语法错误在代码运行前就已经出现了
* 异常会导致后面的代码无法正常执行
* 异常捕获处理的目的就是为了当异常出现后不会影响后面代码的执行

## 面向对象
1. 什么是对象？
* 万物皆对象
* 对象的特征和行为

2. Js中的对象：
* 无序的键值对的集合 hash算法 ，索引才是有序的，键值是无序的
* 属性对应着特征
* 函数方法对应着行为

3. 面向对象能够解决什么？
* 解决了全局变量污染
* 解决了代码混乱*

### 创建对象
1. 使用字面量的方式
* 通过对象字面量创建对象的时候本质是在调用new Object
* 通过数组字面量创建对象的进修本质是在调用new Array
* 通过正则字面量创建对象的时候本质是在调用new RegExp

2. 使用函数封装
```js
var createPerson=function(name,age){
    var obj=new Object();
    obj.name=name;
    obj.age=age;
    return obj;
}
var jack=createPerson('jack',20);
```

3. 使用自定义构造函数
```js
function  Person(name,age){
    this.name=name;
    this.age=age;
}
var per1=new Person('jack',20);
```
4. 工厂模式
```js
function createPerson(name, age, gender){
    var obj = {};
    obj.name = name;
    obj.age = age;
    obj.gender = gender;
    return obj;
}
//工厂模式中的this是window，因为调用模式是函数调用模式
var p = createPerson("", 19, "male");
```

5. 寄生模式
```js
function createPerson(name, age, gender){
    var obj = {};
    obj.name = name;
    obj.age = age;
    obj.gender = gender;
    return obj;
}
//寄生模式中的this指向的是new创建出来的对象！
var p = new createPerson("", 18, "male");
```

### Array对象

|方法|描述|
|--|--|
|concat()|连接两个或更多的数组，并返回结果。|
|join()|把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。|
|pop()|删除并返回数组的最后一个元素|
|push()|向数组的末尾添加一个或更多元素，并返回新的长度。|
|reverse()|颠倒数组中元素的顺序。|
|shift()|删除并返回数组的第一个元素|
|slice()|从某个已有的数组返回选定的元素|
|sort()|对数组的元素进行排序|
|splice()|删除元素，并向数组添加新元素。|
|unshift()|向数组的开头添加一个或更多元素，并返回新的长度。|

### Boolean对象

|方法|描述|
|--|--|
|toString()|把逻辑值转换为字符串，并返回结果。|
|valueOf()|返回 Boolean 对象的原始值。|

### Date对象

|方法|描述|
|--|--|
|Date()|返回当日的日期和时间|
|getDate()|从 Date 对象返回一个月中的某一天 (1 ~ 31)。|
|getDay()|从 Date 对象返回一周中的某一天 (0 ~ 6)。|
|getMonth ()|从 Date 对象返回月份 (0 ~ 11)。|
|getFullYear()|从 Date 对象以四位数字返回年份。|
|getYear()|请使用 getFullYear() 方法代替。|
|getHours()|返回 Date 对象的小时 (0 ~ 23)。|
|getMinute s()|返回 Date 对象的分钟 (0 ~ 59)。|
|getSeconds()|返回 Date 对象的秒数 (0 ~ 59)。|
|getMilliseconds()|返回 Date 对象的毫秒 (0 ~ 999)。|
|getTime()|返回 1970 年 1 月 1 日至今的毫秒数。 |
|parse()|返回1970年1月1日午夜到 指定日期（字符串）的毫秒数。|
|setDate()|设置 Date 对象 中月的某一天 (1 ~ 31)。|
|setMonth()|设置 Date 对象中月份 ( 0 ~ 11)。|
|setFullYear()|设置 Date 对象中的年份（四位数字）。|
|setYear()|请使用 setFullYear() 方法代替。|
|setHours()|设置Date 对象中的小时 (0 ~ 23)。|
|setMinutes()|设置 Date 对象ä­的分钟 (0 ~ 59)。|
|setSeconds()|设置 Date 对象中的秒钟 (0 ~ 59)。|
|setMilliseconds()|设置 Date 对象中的毫秒 (0 ~ 999)。|
|setTime()|以毫秒设置 Date 对象。|
|toString()|把 Date 对象转换为字符串。|
|toTimeString()|把 Date 对象的时间部分转换为字符串。|
|toDateString()|把 Date 对象的日期部分转换 为字符串。|

### Math对象

#### Math对象的属性

|属性|描述|
|--|--|
|E|返回算术常量 e，即自然对数的底数（约等于2.718）。|
|LN2|返回 2 的自然对数（约等于0.693）。|
|LN10|返回 10 的自然对数（约等于2.302）。|
|LOG2E|返回以 2 为底的 e 的对数（约等于 1.414）。|
|LOG10E|返回以 10 为底的 e 的对数（约等于0.434）。|
|PI|返回圆周率（约等于3.14159）。|
|SQRT1_2|返回返回 2 的平方根的倒数（约等于 0.707）。|
|SQRT2|返回 2 的平方根（约等于 1.414）。|

#### Math对象的方法

|属性|描述|
|--|--|
|abs(x)|返回数的绝对值。|
|acos(x)|返回数的反余弦值。|
|asin(x)|返回数的反正弦值。|
|atan(x)|以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。|
|atan2(y,x)|返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。|
|ceil(x)|对数进行上舍入。|
|cos(x)|返回数的余弦。|
|exp(x)|返回 e 的指数。|
|floor(x)|对数进行下舍入。|
|log(x)|返回数的自然对数（底为e）。|
|max(x,y)|返回 x 和 y 中的最高值。|
|min(x,y)|返回 x 和 y 中的最低值。|
|pow(x,y)|返回 x 的 y 次幂。|
|random()|返回 0 ~ 1 之间的随机数。|
|round(x)|把数四舍五入为最接近的整数。|
|sin(x)|返回数的正弦。|
|sqrt(x)|返回数的平方根。|
|tan(x)|返回角的正切。|
|toSource()|返回该对象的源代码。|
|valueOf()|返回 Math 对象的原始值。|

### Number对象

#### Number 对象属性 

|属性|描述|
|--|--|
|MAX_VALUE|可表示的最大的数。|
|MIN_VALUE|可表示的最小的数。|
|NaN|非数字值。相当于NaN|
|NEGATIVE_INFINITY|负无穷大，溢出时返回该值。相当于-Infinity|
|POSITIVE_INFINITY|正无穷大，溢出时返回该值。相当于Infinity|

#### Number 对象方法

|方法|描述|
|--|--|
|toString|把数字转换为字符串，使用指定的基数。|
|toFixed|把数字转换为字符串，结果的小数点后有指定位数的数字。|
|toExponential|把对象的值转换为指数计数法。|
|toPrecision|把数字格式化为指定的长度。|
|valueOf|返回一个 Number 对象的基本数字值。|

### String对象


|方法|描述|
|--|--|
|anchor()|创建 HTML 锚。|
|big()|用大号字体显示字符串。|
|blink()|显示闪动字符串。|
|bold()|使用粗体显示字符串。|
|fontcolor()|使用指定的颜色来显示字符串。|
|fontsize()|使用指定的尺寸来显示字符串。|
|italics()|使用斜体显示字符串。|
|link()|将字符串显示为链接。|
|small()|使用小字号来显示字符串。|
|strike()|使用删除线来显示字符串。|
|sub()|把字符串显示为下标。|
|fixed()|以打字机文本显示字符串。|
|sup()|把字符串显示为上标。|
|charAt()|返回在指定位置的字符。|
|charCodeAt()|返回在指定的位置的字符的 Unicode 编码。|
|concat()|连接字符串。|
|fromCharCode()|从字符编码创建一个字符串。|
|indexOf()|检索字符串。|
|lastIndexOf()|从后向前搜索字符串。|
|match()|找到一个或多个正则表达式的匹配。|
|replace()|替换与正则表达式匹配的子串。|
|search()|检索与正则表达式相匹配的值。|
|slice()|提取字符串的片断，并在新的字符串中返回被提取的部分。|
|split()|把字符串分割为字符串数组。|
|substr()|从起始索引号提取字符串中指定数目的字符。|
|substring()|提取字符串中两个指定的索引号之间的字符。|
|toLocaleLowerCase()|把字符串转换为小写。|
|toLocaleUpperCase()|把字符串转换为大写。|
|toLowerCase()|把字符串转换为小写。|
|toUpperCase()|把字符串转换为大写。|
|toSource()|代表对象的源代码。|
|toString()|返回字符串。|
|valueOf()|返回某个字符串对象的原始值。|

### 面向对象的三大特性：封装，继承，多态
1. 封装：将功能封装在对象中，对象会提供外部使用的接口，外界在使用的时候，只需要考虑如何调用接口，而不需要考虑内部的具体实现。
2. 继承：js中的某些对象没有一些需要的属性和方法，但是另外的对象有，那么拿过来使用，就是继承
3. 多态：js中没有多态，多态一般是体现在强类型的编程语言中。

### 继承

#### 继承的实现方式
1. 混入式(max-in)继承：通过循环将一个对象中的所有属性和方法混入到另外一个对象中
```js 
var me={
    work:function(){
        console.log('打工');
    }
};
var mayun={
    money:9999999999,
    car:'QQ',
    manager:function(){
        console.log('管理阿里巴巴。。。');
    }
}
/*遍历，让me对象拥有mayun对象的所有属性*/
for(var key in mayun){
    me[key]=mayun[key];
}
```

2. 使用原型实现继承
    * 修改构造函数的protoType属性来设置原型，但是原型只有一个，所以这种方式无法指定多种原型，后面指定的原型会覆盖前面指定的原型
    * 利用混入的方式给原型添加属性和方法

3. 经典的实现继承的方式
* Object.create()：
* 解决兼容问题：
```js
    var source={
        name:'jack',
        age:20
    }
    /*解决经典继承方式的兼容*/
    function myCreate(){
        /*判断浏览器是否支持经典继承方式*/
        if(Object.create){
            var son=Object.create(source);
            return son;
        }
        else{
            function UserDefine(){}
            UserDefine.prototype=source;
            var son=new UserDefine();
            return son;
        }
    }
```
#### 继承的使用—扩展内置对象
1. 如何安全的扩展内置对象--不能直接为系统的内置对象扩展属性和方法，因为它是共用的
* 创建自定义的构造函数
* 实现原型继承，如继承自一个数组对象
* 为自定义的构造函数的原型扩展属性和方法
* 通过自定义的构造函数创建出的对象，既拥有系统数组的属性和方法，又拥有自定义的属性和方法
* 自定义的类型不会对其它的类型产生影响
2. 示例：
```js
    /*使用js内置对象*/
    var arr1=new Array();
    /*为系统的内置对象添加一些自定义属性或方法*/
    Array.prototype.sayHi=function(){
        console.log('我是第一个对象');
    }
    arr1.sayHi();

    /*创建第二个对象*/
    var arr2=new Array();
    /*为第二个对象添加自定义的属性或方法 */
    Array.prototype.sayHi=function(){
        console.log('我是第二个对象');
    }
    arr2.sayHi();
    /*但是，如果再用第一个对象来进行属性或方法的调用，则发现覆盖*/
    arr1.sayHi();
    /*解决：创建自定义数组，为当前数组添加独立的属性或方法，而不是去修改共享的内置对象，否则修改一个，其它使用的时候也发生改变*/
    function  MyArray(){}
    /*让自定义的类型是一个数组--拥有数组的属性和方法 */
    MyArray.prototype=[];
    MyArray.prototype.sayHi=function(){
        console.log('对象1向你问好');
    }
    /*使用自定义类型创建对象*/
    var arr3=new MyArray();
    arr3.push(1,2,3,4,5);
    console.log(arr3);
    arr3.sayHi();
    arr2.sayHi();
    arr1.sayHi();
```

### 构造函数
1. 什么是构造函数：构造函数是用来初始化对象的

2. 构造函数的特征：
* 首字母大写--规范
* 构造函数一般和new关键字一起使用
* 构造函数不需要手动的写返回值

3. 构造函数的执行过程：
* 通过new关键字创建对象
* 调用构造函数将构造函数中的this指向创建出来的对象
* 在构造函数内部，通过this对对象新增属性和方法--初始化操作
* 自动返回创建好的对象

4. 注意事项
* 如果在构造函数中写了return语句
    * 如果返回了简单数据类型，不会对构造函数的返回值造成影响，依然是构造函数中创建的对象
    * 如果返回了复杂数据类型，则会返回该复杂数据类型
* 如果像调用普通函数一样调用构造函数
    * 函数中的this会指向window对象，通过this添加的所有属性和方法会添加到window对象以上	
    * 如果函数中没有return语句，则返回undefined

5. 传统构造函数存在的问题 
    * 资源浪费
    * 全局变量增多，会增加引入框架命名冲突的风险
    * 代码结构混乱，会变得难以维护
> 使用原型解决构造函数问题,所有对象共享神秘对象(构造函数.prototype)内的属性和方法    

### 原型 
1. 什么是原型：构造函数在创建出来的时候，系统会默认帮这个构造函数创建并且关联一个空的对象， 这个对象就是原型

2. 原型的作用：通过和原型关联的构造函数所创建出来的所有对象，都会共享原型中声明的属性和方法—(相当于后台语言中的父类)

3. 如何访问原型：可以通过构造函数名称.protoType获取原型。如：Person.prototype

4. 如何在原型中添加属性和方法：
* 利用对象的动态特性为原型添加属性和方法 。具体可以通过类型.protoType来添加属性和方法,如:
```
Person.prototype.address='北京';
console.log(per.address);
```

* 直接为构造函数的原型属性protoType赋值一个新的对象
```js
Person.prototype={
    gender:'male',
    phone:'12345'
}
var per2=new Person();
console.log(per2.phone);
```
5. 使用原型注意事项：
* 原型的成员需要先添加再使用
* 公共的成员才可以放到原型中，不同对象的不同的属性应该放在各自对象内
* 在获取某些成员的时候，如果当前对象中没有，才会去原型中获取
* 在使用对象设置属性的值的时候，只会在对象自身进行查找，如果有，就进行修改，如果没有就会新增
* 在给构造函数的原型属性protoType赋值一个新的对象，会造成赋值前后创建的对象所指向的原型不一样，所以建议先赋值新对象之后再通过构造函数创建对象

6. __proto__属性的介绍
```js 
    function  Person(name,age){
        this.name=name;
        this.age=age;
    }
    var p=new Person('jack',20);
    console.log(Person.prototype);
    /*__proto__是一个非标准的属性，不同浏览器会有兼容的问题，所以不推荐在工作和项目中使用，只在自己调试代码的时候使用*/
    console.log(p.__proto__);
    console.log(Person.prototype === p.__proto__);
```
7. constructor属性：
```js
    function  Person(){
    }
    /*constructor:指向和原型对应的构造函数*/
    console.log(Person.prototype.constructor);
    console.log(Person.prototype.constructor === Person); //true
```
注意：当构造函数.protoType重新赋值为一个新的对象的时候，新的对象中需要手动新增constructor属性，让原型可以正常的和构造关联起来，但是constructor属性不是必须要修改的内容，如果没有重新指向，对使用也不会有影响，但是一般情况下，都推荐改成正常的指向。   

### 原型链：
1. 概念：对象都有原型，原型是一个对象，所以原型又有原型，这样就形成了一个原型链
2. 属性搜索原则：当使用对象去访问一个属性或者方法的时候
* 先在对象自身中进行查找，如果找到就直接使用
* 如果没有找到，就去对象的原型中进行查找，如果找到直接使用
* 如果没有找到，就沿着原型链依次向上查找，直到找到null
3. instanceof关键字
* 判断构造函数的protoType属性是否在对象的原型链上
4. 完整的原型链：函数有两重身份，一重是构造函数，一重是对象
<img src="/images/posts/js/JS加强/2.png" width = "500" />

### Function
1. 函数也是一个对象，对象都是通过构造函数创建的，函数的构造函数就是Function,,JS中所有的函数的构造函数都是Function,可以通过new Function()来创建

2. Function初步使用：
```js 
    /*1.如果直接使用new Function()而不传入任何的参数，那么就会创建出一个匿名函数
    * 2.可以给函数传递一个参数，这个参数后期就会成为函数的函数体*/
    /*var fun=new Function();
     console.log(typeof fun);
     console.log(fun);*/
    var fun=new Function('console.log("能不能输出")');
    fun();
    /*3.也可以给函数传入多个参数，前面的参数都是函数的参数，最后一个是函数体*/
    var calculate=new Function("a","b","return a+b;");
    var result=calculate(4,5);
    console.log(result);
```

3.Function代码过长的问题的解决：
* 拼接字符串
* 使用反引号``
* 使用\
* 使用模板

4. eval函数的使用：可以将字符串的内容当成js代码来执行
```js
    /*可以将eval中的字符串当成代码来解析*/
    eval("var num=100;");
    console.log(num);
    /*可以将json格式字符串转换为json对象
    * 注意：
    * 1.eval函数会将json格式的字符串的{}当成代码块处理，造成报错
    * 2.所以。可以给这个json字符串前后拼接一个()
    * 3.这样，加了()后的字符串就会被认为是一个字面量来处理了*/
    var jsonStr='{"name":"jack","age":20}';
//    var obj=eval("("+jsonStr+")");
    eval("var obj="+jsonStr);
    console.log(obj);
```

5. 函数对象的属性
* arguments:函数内部的一个变量，它是一个伪数组。当函数被调用的时候，会将所有的实参依次存入这个伪数组中，它只有在函数被调用的时候才会有值，它与函数.arguments的功能一样，存储的内容也一样，但并非同一个对象
* caller:获取当前函数是在哪个函数中被调用，注意，这个属性值必须在函数被调用的才能取到值，所以需要将 函数.caller 代码写在函数体内，当这段代码被执行的时候，就是这个函数被调用的时候。同时需要注意的时候，如果是全局调用，那么caller只能返回null
* length:形参的数量
* name:函数名称.通过函数表达式声明的函数，函数的name就是变量名称
* protoType:函数的原型

6. 函数的作用域链：
* 只有函数可以创建作用域
* 在函数中可以嵌套函数，这样就形成了作用域中嵌套另外一个作用域，这就形成了作用域链
* 作用域链中变量的搜索原则：
    * 首先在当前使用变量的作用域中查找，如果找到就使用，否则查找上一级作用域
    * 查找上一级作用域，如果找到就使用，否则再查找上一级作用域
    * 如果没有，就一直沿着作用域往上找，直到找到全局的作用域为止
* 访问规则：由内至外
    * 内层作用域可以访问外层作用域中的变量
    * 外层作用域不能直接访问内层作用域中的变量

7. 函数的原型链：
<img src="/images/posts/js/JS加强/1.png" width = "500" />

### 函数的四种调用模式
    函数中的this，调用方式不同，指向不同;this与调用有关，与定义无关

1. 函数调用模式
- 函数名() || (function(){}()) ==> window

2. 方法调用模式
- 对象.方法名() || 对象[方法名]() || 祖对象.父对象.子对象.方法名() ==> 宿主对象

3. 构造器调用模式
- new 构造函数() || new 对象.构造函数() ==> new出来的新实例

4. 间接调用模式(上下文调用模式)
-使用注意事项
    * 当call和apply的第一个参数传入的是一个值类型的数据的时候，这个时候函数中的this会指向值类型对应的引用类型的数据
    * 当call和apply的第一个参数传入的是undefined或者null或者不传的时候，函数中的this指向window对象
- call
    + 函数.call(指定的this，实参1，实参2，...)
    + 对象.方法.call(指定的this，实参1，实参2，...)
 ```js
函数名.call(要让this指向的对象, arg1, arg2...argN);
//1. 调用函数
//2. 让函数中的this指向，第一个参数中的对象
//3. 把第二个及以后所有的参数依次传递给函数作为实参！
```
- apply
    + 函数.apply(指定的this，[实参1，实参2，...])
    + 函数.apply(指定的this，{0: 实参1， 1：实参2， length: 2})
    + 对象.方法.apply(指定的this，[实参1，实参2，...]) 
```js
函数名.apply(要让this指向的对象, 数组或者伪数组);
//1. 调用函数
//2. 让函数中的this指向，第一个参数中的对象
//3. 把第二个参数中的数组或者伪数组拆解开，依次传递给函数作为形参（很常用的特性）
```      

### 伪数组
1.概念：伪数组拥有与数组一样的下标，可以通过下标来访问各种元素，拥有长度属性，可以表示其中存储的元素的数量。但是没有数组类似的方法

### 静态成员和实例成员：
1. 静态成员：通过构造函数访问的成员  >>  函数名.成员

2. 实例成员：通过实例对象访问的成员  >>  实例对象.成员


### 作用域：
1. 概念：变量起作用的范围

2. 在js中，只有函数可以创建作用域

3. 词法作用域(静态作用域)：根据代码的书写结构去确定变量的作用范围，与调用没有关系。意味着在使用一个变量的时候，首先在自己的作用域中查找，如果没有就去上一级作用域中查找

4. 注意：js中没有块级作用域，意味着在if或者for中定义的变量在它们的外部也能够访问

### 变量名提升：
1. js代码的执行过程包含：预解析和执行

2. 在代码的预解析阶段，js引擎会将所有的变量声明，以及函数声明提升到其所在的作用域的最顶端

3. 当函数和函数同名，都会进行提升，造成后面声明的函数覆盖前面的函数

4. 当函数和变量名同名的时候，只会提升函数，忽略变量的声明

5. 用表达式创建的函数不能进行提升，只有对应的变量名称能够进行提升

6. 条件式函数声明：就是在条件语句是声明的函数，在变量提升的时候会被当函数表达式来处理

7. 变量提升是分Script标签的。所有的全局的函数或者变量的声明，只会被提升到当前Script标签的最顶端

### Object.defineProperty
1 .作用：这个方法会直接在一个对象上定义一个新的属性或者修改一个已经存在的属性，并返回这个对象。

2. 语法：Object.defineProperty(obj,prop,descriptor)
* Obj:要添加属性或者修改属性的对象
* Prop:要修改或者添加的属性名称
* Descriptor:标记属性能否被删除，修改或者遍历。。。相当于配置属性的特性，它是一个对象

3. 注意：get/set方法不能和value和writable属性一起使用

### 小方法

#### in运算符
1. 作用
    * 遍历对象
    * 判断对象是否可以访问到某个属性.而不关注这个属性在自身定义还是“父级类”中定义

2. 注意
    * 如果访问一个对象不存在的属性--undefined
    * 如果访问一个不存在的变量--报错
```js
for(var key in obj){}
或者   
console.log('name' in obj)
```
#### foreach
1. foreach:是数组的方法,只能使用数组对象调用,并不能遍历对象
    * value:当前遍历到的元素值
    * index:当前元素的索引
    * arr:当前遍历的数组
```js
    arr.forEach(function(value,index,arr){
        console.log(value);
    })
```

#### map
```js
数组.map(function(value, index, arr){
})
//value 当前正在遍历的元素
//index 当前正在遍历的元素的所以
//arr 当前正在遍历的数组
//map方法的返回值，将每次调用回调函数的返回值组合成一个新的数组，作为这个map的返回值
```

### 闭包
1. 闭包的概念
    * 一个具有封闭的对外不公开的, 包裹结构, 或空间(闭包就是指函数内部声明的函数)
    * 在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包.
    * 闭包的实现的结构：函数内部声明调用，将函数返回
    * 作用：可以让函数外部来操作函数内部的成员，说白了就是函数内外交互的桥梁

2. 闭包要解决什么问题
    * 闭包内的数据不允许外界访问
    * 要解决的问题就是间接访问该数据

3. 闭包的基本结构
    * 写一个函数, 函数内定义一个新函数, 返回新函数, 用新函数获得函数内的数据        
    * 写一个函数, 函数内定义一个对象, 对象中绑定多个函数( 方法 ), 返回对象, 利用对象的方法访问函数内的数据

4. 闭包的问题
    * 如果会造成外部对闭包内部的成员的引用，如果外部的成员不释放会造成闭包内部的成员也无法释放，造成性能消耗
    * 如果反复的调用闭包函数，会反复的创建闭包内部的成员

5. 闭包使用场景
    * 当函数外部需要使用函数内部声明的成员的时候
    * 函数需要拥有属于他单独使用的唯一变量的时候    


### 沙箱模式
1. 不是每一个沙箱都会传递window,如果有需要才会传递

2. 沙箱的原则 是内部不直接访问外部，外部也不会直接访问内部，如果不传递window参数，那么就破坏了这个宗旨

3. 代码以后需要做压缩,如果在沙箱中直接使用外部的window对象，那么沙箱内的有关window的代码无法做压缩
```js
//IIFE 立即执行函数表达式
(function(window){
    //变量的声明
    //功能的实现
    //如果需要的话，就通过window对象向外界暴露接口
})(window)
//只要在沙箱中用到的外部的内容，就要将该内容已传参的方式传到沙箱内部
//框架
//组件
//插件
```

### 严格模式
语法要求更加严格的模式

```js
//开启严格模式
"use strict"
'use strict'
```
#### 严格模式下的要求
1. 使用变量必须使用var
2. 函数的形参不能重名
3. 对象的属性不能重名（ES6之后不存在这个问题）
4. 八进制的数字不能使用
5. eval有自己的作用域
6. 不能删除无法删除的属性Object.prototype
7. 不能给只读属性赋值 Object.prototype